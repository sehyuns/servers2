// @file	socket_async.cpp
//
//

#include "socket_async.h"

#include "message_buffer.h"

namespace lib
{
	////////////////////////////////////////////////////////////////////////////////
	//
	////////////////////////////////////////////////////////////////////////////////
	SocketAsync::SocketAsync()
#if defined(USE_ADVANCED_NETWORK)
		: _accept_func(nullptr)
		, _connect_func(nullptr)
#endif
	{

	}

	////////////////////////////////////////////////////////////////////////////////
	//
	////////////////////////////////////////////////////////////////////////////////
	SocketAsync::~SocketAsync()
	{

	}

	////////////////////////////////////////////////////////////////////////////////
	//
	////////////////////////////////////////////////////////////////////////////////
	INT32	SocketAsync::initialize(const SOCKET& socket_in)
	{
		if (INVALID_SOCKET == socket_in)
		{
			_socket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);
			if (INVALID_SOCKET == _socket)
			{
				recorde_error();
				return ERR_SOCKET_CREATE;
			}
		}
		else
		{
			_socket = socket_in;
		}

		return ERR_SUCCEEDED;
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	////////////////////////////////////////////////////////////////////////////////
	VOID	SocketAsync::close()
	{
		Socket::close();
	}

#if defined(USE_ADVANCED_NETWORK)
	////////////////////////////////////////////////////////////////////////////////
	//
	////////////////////////////////////////////////////////////////////////////////
	INT32 SocketAsync::advanced_accept()
	{
		return SOCKET();
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	////////////////////////////////////////////////////////////////////////////////
	INT32 SocketAsync::advanced_connect()
	{
		return INT32();
	}
#endif

	////////////////////////////////////////////////////////////////////////////////
	//
	////////////////////////////////////////////////////////////////////////////////
	INT32 SocketAsync::receive_async(MessageBuffer * buf_in)
	{
		memset(&_overlapped, 0, sizeof(OVERLAPPED));
		_overlapped.set_type(EO_RECEIVE);

		DWORD transferred_bytes = 0;
		DWORD flag = 0;
		if (SOCKET_ERROR == WSARecv(_socket, buf_in->get_wsa_buf(), 1, &transferred_bytes, &flag, &_overlapped, NULL))
		{
			recorde_error();
			return ERR_SOCKET_RECV;
		}
		return ERR_SUCCEEDED;
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	////////////////////////////////////////////////////////////////////////////////
	INT32 SocketAsync::send_async(MessageBuffer * buf_in)
	{
		memset(&_overlapped, 0, sizeof(OVERLAPPED));
		_overlapped.set_type(EO_SEND);

		DWORD transferred_bytes = 0;
		DWORD flag = 0;

		if (SOCKET_ERROR == WSASend(_socket, buf_in->get_wsa_buf(), 1, &transferred_bytes, flag, &_overlapped, NULL))
		{
			recorde_error();
			return ERR_SOCKET_SEND;
		}
		return ERR_SUCCEEDED;
	}
}